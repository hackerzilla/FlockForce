<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Website Title</title> </head>
	<link rel="stylesheet" href="styles.css">  </head>
	<body>

		<div style="text-align: right; padding: 10px 20px;">
			<button id="theme-toggle-button">Switch to Dark Mode</button>
		</div>
		<nav id="sidebar-nav">
			<a href="#" class="back-to-top-button" title="Back to Top">
				<img src="FlockForceSidebar.jpg" alt="Back to Top - Flock Force Logo" class="sidebar-logo">
			</a>
			<ul>
				<li><a href="#abstract">Abstract</a></li>
				<li><a href="#technical-approach">Technical Approach</a></li>
				<li><a href="#results">Results</a></li>
				<li><a href="#references">References</a></li>
				<li><a href="#contributions">Contributions</a></li>
				</ul>
		</nav>
		<div class="container">
			<header>
				 <img src="FlockForce.jpg" alt="Flock Force Logo" class="logo">
				 <p>Team Members: Julian Pearson Rickenbach, Mark Yuzon, Connor Armstrong, John Yoon</p>
				<p>CS184 Final Report</p>
			</header>
	
			<main>
	
				<section id="abstract">
					<h2>Abstract</h2>
					<p>
						FlockForce is a 3D boid simulation accelerated with compute shader and made in Godot Engine. Our team started out with a blank Godot project, and we ended up with a convincing Boids implementation in an easily extendable format. Our simulation uses the GPU to accelerate the calculation of positions and velocities, however, the rendering is still taken care of by Godot’s Forward+ rendering pipeline, meaning that the individual boids are still interactable at the game engine level. This affords the opportunity for the boids to interact with other components of the game engine, for example, the physics engine, where other implementations of compute shader boids would have the particles exist purely on the GPU. While our design choice comes at the cost of performance, we believe it to be a worthwhile tradeoff for the opportunities it affords for creative expression.
					</p>
				</section>
	
				<section id="technical-approach">
					<h2>Technical Approach</h2>
					<p>
						FlockForce centers around the boid algorithm invented by Craig Reynolds in 1986, which approximates the behavior of animals that form flocks, swarms, or schools. The algorithm is inspired by research into birds, which found that the flocking behavior of starlings follows simple rules at the level of individual organisms. It makes sense then that the boids algorithm is also relatively simple, although tuning it to produce pleasing results is still an implementation-specific challenge. For our implementation, we followed a philosophy of starting simple and adding complexity as needed. Our first draft of boids was a CPU-driven program that performed the O(n^2) neighborhood search, where n is the number of boids. As the article by Craig Reynlods describes, the velocity of each boid at any given timestep is the sum of three vectors: cohesion, separation, and alignment. The cohesion vector points from a boid to the center of mass of its neighbors (within some neighborhood radius). The separation vector points away from the center of mass of neighbors that are too close (an inner radius). Finally, the alignment vector points in the direction of the average heading of its neighbors. 
					</p>
					<p>
						Creating the CPU boids implementation was worthwhile because it gave us both a sanity check and a benchmark for how much we could improve the performance. On an Apple M2 Pro, the CPU boids implementation was able to run smoothly for up to roughly 100 boids. This made sense as the algorithm has an O(n^2) time complexity, since each boid needs to check every other boid for presence in the local neighborhood. 
					</p>
					<p>
						After successfully implementing the CPU boids, we set out to offload the work to the GPU. This task was more difficult than we initially thought. Fortunately, Godot has a helpful abstraction for interacting with the GPU. Godot has a RenderingDevice abstraction that encapsulates the boilerplate of setting up bindings for buffers, uniforms, shaders, compute pipelines, and more. Still, though, we had to learn what is required in order to send data buffers to the GPU and dispatch calls to run the desired shader. Debugging and understanding the compute shader pipeline was where much of the effort went. The effort was worth it when we were able to achieve greater than 10x the number of boids on-screen as compared to CPU-boids. 
					</p>
					<p>
						To get there, we started simple with basic tests of binding buffers to uniforms, setting up the uniform set and compute pipeline, and getting the data back from the storage buffers after the CPU synchronized with the GPU. From there, we could reason about loading the boid positions into buffers, sending them off to the GPU, and retrieving the updated positions and setting them on the CPU. 
					</p>
					<p>
						We had many, many bugs along the way. To name a few, we completely neglected having a swap buffer implementation initially (we were updating the boid positions and velocities in-place), which resulted in some slightly offsetting boid movement. To fix this we doubled our buffers. Positions and velocities would be read from buffers A and updated positions would be written to buffers B, then the roles of A and B would be swapped. This removes the data dependencies that in-place updates caused. 
					</p>
					<p>
						Another bug, which was much more pernicious than the previous one, was an issue with implicit padding of data in the arrays on the GPU. We had arrays of vec3s (3-Vectors in GLSL), which held positions and velocities. What we didn’t realize at the time is that, for some reason, an extra 4 bytes was inserted between vec3’s, causing very strange jittering behavior in the visualization due to the data being returned not being in the expected format (i.e. not being in the format we sent to the GPU). The fix was a quick one, on the CPU side of things, we simply inserted an extra float in the byte array that we pass to the GPU. 
					</p>
	
					<h3>Techniques, Algorithms, and Implementation</h3>
					<p>
						[Describe the specific techniques and algorithms you used or implemented. Explain the core concepts clearly. Detail how you implemented them. Be specific about libraries or frameworks used if applicable.]
					</p>
					<ul>
						<li>[Detail about Technique 1...]</li>
						<li>[Detail about Algorithm 2...]</li>
					</ul>
	
					<h3>Comparison to References & Unique Decisions</h3>
					 <p>
						[Discuss how your approach relates to existing work or references you used. Did you implement a subset of a paper's method? Did you combine multiple approaches? Did you enhance or change anything? Clearly state the unique decisions your team made regarding the implementation or approach and justify why those decisions were made.]
					 </p>
	
					<h3>Problems Encountered and Solutions</h3>
					<p>
						[Describe the significant technical challenges or problems you encountered during the project. For each problem, explain how you identified it and the steps you took to tackle or overcome it.]
					</p>
					<ul>
						<li><strong>Problem:</strong> [Description of Problem 1] <br> <strong>Solution:</strong> [How you tackled it]</li>
						<li><strong>Problem:</strong> [Description of Problem 2] <br> <strong>Solution:</strong> [How you tackled it]</li>
					</ul>
	
	
					<h3>Lessons Learned</h3>
					<p>
						[Reflect on the key takeaways from the project. What did you learn about the technical subject, project management, teamwork, debugging, etc.?]
					</p>
	
				</section>
	
				<section id="results">
					<h2>Results</h2>
					<p>
						[Present your final results. Include relevant images, animations, or videos. Provide context for each result. You can include extra results not shown in the final presentation.]
					</p>
	
					<figure>
						<img src="images/result_image_1.png" alt="[Description of what this image shows]">
						<figcaption>Figure 1: Brief description of this result image.</figcaption>
					</figure>
	
					<figure>
						<img src="images/result_image_2.jpg" alt="[Description of what this image shows]">
						<figcaption>Figure 2: Another result, perhaps showing a different aspect or comparison.</figcaption>
					</figure>
	
					<figure>
						 <video controls width="100%">
							<source src="videos/result_demo.mp4" type="video/mp4">
							Sorry, your browser doesn't support embedded videos.
							You can <a href="videos/result_demo.mp4">download the video</a> instead.
						 </video>
						 <figcaption>Video 1: Demonstration of [feature shown in video].</figcaption>
					</figure>
	
					</section>
	
				<section id="references">
					<h2>References</h2>
					 <ul>
						<li>[1] Author(s). (Year). *Title of Paper or Resource*. Journal or Source, Volume(Issue), pages. [Optional: <a href="URL_if_available" target="_blank">Link</a>]</li>
						<li>[2] Author(s). *Website or Book Title*. Retrieved from [URL] or Publisher.</li>
						<li>[3] ...</li>
						</ul>
				</section>
	
				<section id="contributions">
					<h2>Contributions</h2>
					<p>Detailed breakdown of contributions from each team member:</p>
					 <ul>
						<li><strong>[Team Member 1 Name]:</strong> [Specific tasks, features implemented, sections written, etc.]</li>
						<li><strong>[Team Member 2 Name]:</strong> [Specific tasks, features implemented, sections written, etc.]</li>
						<li><strong>[Team Member 3 Name, if any]:</strong> [Specific tasks, features implemented, sections written, etc.]</li>
						 </ul>
				</section>
	
			</main>
	
			<footer>
				<p>CS184 Final Project | [University Of California, Berkeley] | [Spring 2025]</p>
			</footer>
	
		</div> 
		<script src="scripts.js"></script>
	</body>
	</html>